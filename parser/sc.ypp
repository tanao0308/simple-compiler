%language "C++"
%defines
%locations
%skeleton "lalr1.cc"
%define api.value.type variant
%define parse.error verbose
%parse-param { Compiler& compiler } // ast 的根节点

%{
%}

%code requires {
  #include "ast/Compiler.h"
  #include "ast/program/Program.h"
  #include "ast/stmt/Stmt.h"
  #include "ast/stmt/ExprStmt.h"
  #include "ast/stmt/FuncDefStmt.h"
  #include "ast/stmt/VarDefStmt.h"
  #include "ast/stmt/ListStmt.h"
  #include "ast/stmt/ReturnStmt.h"
  #include "ast/stmt/IfStmt.h"
  #include "ast/expr/Expr.h"
  #include "ast/expr/BinaryExpr.h"
  #include "ast/expr/NumberExpr.h"
  #include "ast/expr/VariableExpr.h"
  #include "ast/expr/CallExpr.h"
  namespace yy { class parser; }
}

%code {
  extern int yylex(
    yy::parser::semantic_type* yylval,
    yy::parser::location_type* yylloc
  );
}

// 终结符
%token <double> NUMBER
%token <std::string> IDENT
%token DEF RETURN IF ELSE

// 非终结符
%type <std::unique_ptr<Program>> program
%type <std::unique_ptr<Stmt>> stmt
%type <std::unique_ptr<Stmt>> simple_stmt
%type <std::vector<std::unique_ptr<Stmt>>> list_stmt
%type <std::unique_ptr<Expr>> expr

// 优先级
%left '+' '-'
%left '*' '/'
%left '^'

%%
program
    : list_stmt {
          $$ = std::make_unique<Program>(std::move($1));
          compiler.setRoot(std::move($$));
      }
    ;
stmt
    : simple_stmt {
      { $$ = std::move($1); }
    }
    | '{' list_stmt '}' // ListStmt
        { $$ = std::make_unique<ListStmt>(std::move($2)); }
    ;
list_stmt
    : list_stmt stmt {
          // 是否能化简为 $$.push_back(std::move($2)) ? TODO
          $1.push_back(std::move($2));
          $$ = std::move($1);
      }
    | stmt {
          $$ = std::vector<std::unique_ptr<Stmt>>();
          $$.push_back(std::move($1));
      }
    ;
simple_stmt
    : expr ';' { // 语句用分号结束
          $$ = std::make_unique<ExprStmt>(std::move($1));
      }
    | IDENT '=' expr ';' { // 变量定义/赋值语句
          $$ = std::make_unique<VarDefStmt>($1, std::move($3));
      }
    | DEF IDENT '(' IDENT ')' stmt { // 新版函数定义语句 def f(x) { y=x*2; return y; }
          $$ = std::make_unique<FuncDefStmt>($2, $4, std::move($6));
      }
    | RETURN expr ';' { // 函数返回语句
          $$ = std::make_unique<ReturnStmt>(std::move($2));
      }
    | IF '(' expr ')' stmt { // if 条件判断
          $$ = std::make_unique<IfStmt>(std::move($3), std::move($5), nullptr);
    }
    | IF '(' expr ')' stmt ELSE stmt { // if 条件判断
          $$ = std::make_unique<IfStmt>(std::move($3), std::move($5), std::move($7));
    }
    ;
expr
    : NUMBER { // 数字表达式
          $$ = std::make_unique<NumberExpr>($1);
      }
    | IDENT { // 变量名表达式
          $$ = std::make_unique<VariableExpr>($1);
      }
    | IDENT '(' expr ')' { // 函数调用表达式
          $$ = std::make_unique<CallExpr>($1, std::move($3));
      }
    | expr '+' expr { // 二元表达式
          $$ = std::make_unique<BinaryExpr>('+', std::move($1), std::move($3));
      }
    | expr '-' expr {
          $$ = std::make_unique<BinaryExpr>('-', std::move($1), std::move($3));
      }
    | expr '*' expr {
          $$ = std::make_unique<BinaryExpr>('*', std::move($1), std::move($3));
      }
    | expr '/' expr {
          $$ = std::make_unique<BinaryExpr>('/', std::move($1), std::move($3));
      }
    | expr '^' expr {
          $$ = std::make_unique<BinaryExpr>('^', std::move($1), std::move($3));
      }
    | '(' expr ')' { // 括号
          $$ = std::move($2);
      }
    ;
%%

namespace yy{
	void
	parser::error(location const &loc, const std::string &s){
			std::cerr << "error at " << loc << ": " << s << std::endl;
	}
}