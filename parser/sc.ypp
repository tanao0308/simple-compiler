%language "C++"
%defines
%locations
%skeleton "lalr1.cc"
%define api.value.type variant
%define parse.error verbose
%parse-param { Program** root } // ast 的根节点

%{
  #include <iostream>
  #include <memory>
  #include <map>
  #include <string>
  #include "ast/program/Program.h"
  #include "ast/stmt/Stmt.h"
  #include "ast/stmt/ExprStmt.h"
  #include "ast/stmt/FuncDefStmt.h"
  #include "ast/expr/Expr.h"
  #include "ast/expr/BinaryExpr.h"
  #include "ast/expr/NumberExpr.h"
  #include "ast/expr/VariableExpr.h"
  #include "ast/expr/CallExpr.h"
  using namespace std;
%}

%code requires {
  #include "ast/program/Program.h"
  #include "ast/stmt/Stmt.h"
  #include "ast/stmt/ExprStmt.h"
  #include "ast/stmt/FuncDefStmt.h"
  #include "ast/expr/Expr.h"
  #include "ast/expr/BinaryExpr.h"
  #include "ast/expr/NumberExpr.h"
  #include "ast/expr/VariableExpr.h"
  #include "ast/expr/CallExpr.h"
  using namespace std;
  namespace yy { class parser; }
}

%code {
  extern int yylex(
    yy::parser::semantic_type* yylval,
    yy::parser::location_type* yylloc
  );
}

// 终结符
%token <double> NUMBER
%token <string> IDENT
%token DEF

// 非终结符
%type <Program*> program
%type <std::vector<Stmt*>*> stmt_list
%type <Stmt*> stmt
%type <Expr*> expr

// 优先级
%left '+' '-'
%left '*' '/'

%%
program
    : stmt_list {
          *root = new Program($1);
      }
    ;
stmt_list
    : stmt_list stmt {
          $1->push_back($2);
          $$ = $1;
      }
    | stmt {
          $$ = new vector<Stmt*>();
          $$->push_back($1);
      }
    ;
stmt
    : expr ';' { // 语句用分号结束
          $$ = new ExprStmt($1);
      }
    | DEF IDENT '(' IDENT ')' '=' expr ';' { // 函数定义语句 def f(x) = x * 2;
          $$ = new FuncDefStmt($2, $4, $7);
      }
    ;
expr
    : NUMBER { // 数字表达式
          $$ = new NumberExpr($1);
      }
    | IDENT { // 变量名表达式
          $$ = new VariableExpr($1);
      }
    | expr '+' expr { // 二元表达式
          $$ = new BinaryExpr('+', $1, $3);
      }
    | expr '-' expr {
          $$ = new BinaryExpr('-', $1, $3);
      }
    | expr '*' expr {
          $$ = new BinaryExpr('*', $1, $3);
      }
    | expr '/' expr {
          $$ = new BinaryExpr('/', $1, $3);
      }
    | IDENT '(' expr ')' { // 函数调用表达式
          $$ = new CallExpr($1, $3);
      }
    | '(' expr ')' { // 括号
          $$ = $2;
      }
    ;
%%

namespace yy{
	void
	parser::error(location const &loc, const std::string &s){
			std::cerr << "error at " << loc << ": " << s << std::endl;
	}
}