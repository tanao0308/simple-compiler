%language "C++"
%defines
%locations
%skeleton "lalr1.cc"
%define api.value.type variant
%define parse.error verbose
%parse-param { Compiler& compiler } // ast 的根节点

%{
  #include <map>
  #include <string>
  #include <memory>
  #include <iostream>
  #include "ast/Compiler.h"
  #include "ast/program/Program.h"
  #include "ast/stmt/Stmt.h"
  #include "ast/stmt/ExprStmt.h"
  #include "ast/stmt/FuncDefStmt.h"
  #include "ast/stmt/VarDefStmt.h"
  #include "ast/expr/Expr.h"
  #include "ast/expr/BinaryExpr.h"
  #include "ast/expr/NumberExpr.h"
  #include "ast/expr/VariableExpr.h"
  #include "ast/expr/CallExpr.h"
%}

%code requires {
  #include "ast/Compiler.h"
  #include "ast/program/Program.h"
  #include "ast/stmt/Stmt.h"
  #include "ast/stmt/ExprStmt.h"
  #include "ast/stmt/FuncDefStmt.h"
  #include "ast/stmt/VarDefStmt.h"
  #include "ast/expr/Expr.h"
  #include "ast/expr/BinaryExpr.h"
  #include "ast/expr/NumberExpr.h"
  #include "ast/expr/VariableExpr.h"
  #include "ast/expr/CallExpr.h"
  namespace yy { class parser; }
}

%code {
  extern int yylex(
    yy::parser::semantic_type* yylval,
    yy::parser::location_type* yylloc
  );
}

// 终结符
%token <double> NUMBER
%token <std::string> IDENT
%token DEF

// 非终结符
%type <std::unique_ptr<Program>> program
%type <std::vector<std::unique_ptr<Stmt>>> stmt_list
%type <std::unique_ptr<Stmt>> stmt
%type <std::unique_ptr<Expr>> expr

// 优先级
%left '+' '-'
%left '*' '/'
%left '^'

%%
program
    : stmt_list {
          $$ = std::make_unique<Program>(std::move($1));
          compiler.setRoot(std::move($$));
      }
    ;
stmt_list
    : stmt_list stmt {
          // 是否能化简为 $$.push_back(std::move($2)) ? TODO
          $1.push_back(std::move($2));
          $$ = std::move($1);
      }
    | stmt {
          // $$ = std::vector<std::unique_ptr<Stmt>>(); // TODO 这里是否必须 new
          $$.push_back(std::move($1));
      }
    ;
stmt
    : expr ';' { // 语句用分号结束
          $$ = std::make_unique<ExprStmt>(std::move($1));
      }
    | IDENT '=' expr ';' { // 变量定义/赋值语句
          $$ = std::make_unique<VarDefStmt>($1, std::move($3));
      }
    | DEF IDENT '(' IDENT ')' '=' expr ';' { // 函数定义语句 def f(x) = x * 2;
          $$ = std::make_unique<FuncDefStmt>($2, $4, std::move($7));
      }
    ;
expr
    : NUMBER { // 数字表达式
          $$ = std::make_unique<NumberExpr>($1);
      }
    | IDENT { // 变量名表达式
          $$ = std::make_unique<VariableExpr>($1);
      }
    | IDENT '(' expr ')' { // 函数调用表达式
          $$ = std::make_unique<CallExpr>($1, std::move($3));
      }
    | expr '+' expr { // 二元表达式
          $$ = std::make_unique<BinaryExpr>('+', std::move($1), std::move($3));
      }
    | expr '-' expr {
          $$ = std::make_unique<BinaryExpr>('-', std::move($1), std::move($3));
      }
    | expr '*' expr {
          $$ = std::make_unique<BinaryExpr>('*', std::move($1), std::move($3));
      }
    | expr '/' expr {
          $$ = std::make_unique<BinaryExpr>('/', std::move($1), std::move($3));
      }
    | expr '^' expr {
          $$ = std::make_unique<BinaryExpr>('^', std::move($1), std::move($3));
      }
    | '(' expr ')' { // 括号
          $$ = std::move($2);
      }
    ;
%%

namespace yy{
	void
	parser::error(location const &loc, const std::string &s){
			std::cerr << "error at " << loc << ": " << s << std::endl;
	}
}